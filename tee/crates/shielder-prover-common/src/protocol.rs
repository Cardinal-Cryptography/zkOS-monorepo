use serde::{Deserialize, Serialize};
use crate::base64_serialization;

use crate::vsock::{VsockClient, VsockServer};

pub const VSOCK_PORT: u32 = 5000;

#[derive(Debug, Serialize, Deserialize)]
pub enum Request {
    /// Message used to determine if TEE server is healthy
    Ping,

    /// Retrieves TEE Public Key, ie key which is used by the user to encrypt inputs to a circuit
    TeePublicKey,

    /// Request to generate proof. A `payload` is encrypted `ciphertext=(R, w, s, pub_sk)`, where
    /// * `R`, `w`, `s` is a relation, witness and statement of ZK-proof we want to generate,
    /// `pub_sk` is a public key generated by the user, which TEE should use to encrypt proof in the response
    GenerateProof {
        #[serde(with = "base64_serialization")]
        payload: Vec<u8>,
        #[serde(with = "base64_serialization")]
        user_public_key: Vec<u8>,
    },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Response {
    /// Response to a health check,
    Pong,

    /// TEE Server public key, used to encrypt payload sent in [`Request::GenerateProof`]
    TeePublicKey{
        public_key: String,
        #[serde(with = "base64_serialization")]
        attestation_document: Vec<u8>,
    },

    /// A ZK-proof computed on the [`Request::GenerateProof`] request. It is encrypted using
    /// a public key sent in the request. Also returns circuit pub_inputs, required for client
    EncryptedProof {
        #[serde(with = "base64_serialization")]
        proof: Vec<u8>,

        #[serde(with = "base64_serialization")]
        pub_inputs: Vec<u8>,
    }
}

pub type ProverServer = VsockServer<Request, Response>;
pub type ProverClient = VsockClient<Request, Response>;
